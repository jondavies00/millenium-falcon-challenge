The solver works by calculating the paths with the chance to have the best odds first. It does this by maintaining a kind of priority queue. Whilst exploring, paths with the least visited bounty hunters (so far) will be explored first. Since we don't care about the shortest route here, we just explore all of these paths equally (with a FIFO queue implementing breadth-first search). Once all paths of a certain amount of bounty hunter captures have been visited, if a successful path was found it will be returned, otherwise the next highest amount of bounty hunter capture paths will be explored. By maintaining this structure we can very quickly find the best-case odds.

If the best-case odds are at a very high amount of bounty hunter captures, and the search space is very large, the algorithm will be slow. The complexity will be $$O((b+1)^d)$$ - where b is the branching factor (average number of nodes possible to explore from any given node) and d is the depth, which will be `countdown - shortest distance to the end node` in the worst case (we can infinitely refuel on the first planet before reaching the destination). 

Regardless, one would expect (on average) this time to be much faster than calculating all successful paths, and finding the best odds out of these. This would be $$O((b+1)^d + n)$$ (where n is the length of the resulting successful paths list).
